# Proxy classes

Proxy классы (по-русски их иногда называют заместителями) определяют объекты, которые внешне ведут себя так же,
как некоторые другие объекты.
Proxy эмулируют поведение других объектов, обычно с добавлением какой-то дополнительной логики,
что может позволить реализовать операции эффективнее с точки зрения памяти или производительности.

Вероятно, объекты самого известного proxy класса возвращает `vector<bool>::operator[]`.
Обычно размер переменной типа `bool` составляет 1 байт, хотя для хранения информации достаточно 1 бита.
`vector<bool>` запаковывает 8 значений в 1 байт, что позволяет экономить память.
Чтобы это работало из `operator[]` приходится возвращать не `bool&`, указывающую на байт, а специальный [объект](https://en.cppreference.com/w/cpp/container/vector_bool/reference),
который хранит информацию как о байте, так и положении бита внутри него. 
Мы оптимизируем память, но заметно теряем производительность из-за постоянной запаковки и распаковки битов.

В качестве другого интересного примера proxy класса можно привести результат арифметических операций над матрицами из библиотеки [Eigen](https://eigen.tuxfamily.org).
Результатом произведения двух матриц оказывается не матрица, а специальный класс [Eigen::Product](https://eigen.tuxfamily.org/dox/classEigen_1_1Product.html),
транспонирование матрицы возвращает [Eigen::Transpose](https://eigen.tuxfamily.org/dox/classEigen_1_1Transpose.html) и ряд других операций также возвращают вспомогательные классы.
Это позволяет производить вычисления лениво, предварительно проанализировав всё выражение, после чего можно его оптимизировать: поменять порядок вычислений, развернуть циклы и избавиться от лишних временных объектов.
Для повышения эффективности вычислений стандарт разрешает возвращать proxy классы арифметическим операторам [valarray](https://en.cppreference.com/w/cpp/numeric/valarray).

Таким образом proxy классы есть в разных библиотеках (включая стандартную) их можно использовать и писать самому,
чтобы программа стала эффективней с точки зрения памяти или производительности.
Иногда это осмысленно.
Для внешнего пользователя proxy классы ведут себя так же, как те классы, которые они эмулируют.

И всё было бы хорошо, если бы у нас не было вывода типов. 
Как только мы начинаем выводить типы, мы натыкаемся на то, что proxy классы имеют не те типы, как у замещаемых ими классов.
И с этого места начинаются неожиданности. 

## Неожиданное поведение

В C++ существуют разные выводы типов.
И они все могут работать неожиданно.
Начнём с `auto` в определении переменной:

```C++
#include <vector>
#include <iostream>

int main() {
    std::vector<bool> v;
    v.push_back(false);

    std::cout << v[0] << "\t";

    auto b = v[0];
    b = true;

    std::cout << v[0] << std::endl;
}
```
Данный код [выводит](https://godbolt.org/z/WT7Es9Gve) `0 1`.
Для любого другого типа изменение значения `b` не привело бы к изменению содержимого вектора.
Дело в том, что при выводе типа `auto` убирает ссылки, но у нас `operator[]` возвращает не ссылку,
а объект, который ведёт себя как ссылка.
В итоге `b` выводится не как `bool`, а как `vector<bool>::reference` и его изменения влияют на вектор.
Разумеется, разные ужасы вида `std::remove_reference<decltype(v[0])>::type` вместо `auto` это не лечат. 

Кроме объявления переменных и функций с auto/decltype у нас есть шаблонные функции с широкими возможностями перегрузок.
```C++
#include <vector>
#include <iostream>
#include <type_traits>

template <typename T>
bool is_integral(T) {
    return std::is_integral_v<T>;
}

int main() {
    std::vector<bool> v{true, false};
    std::cout << is_integral(v[0]) << " " << is_integral(true) << std::endl;
}
```
мы опять [получим](https://godbolt.org/z/aP3r4GWT3) `0 1`, потому что объект прокси класса не является интегральным типом.

Такое поведение вполне определено, но будет явной неожиданностью,
особенно когда проявится на другом конце программы во время рефакторинга или в глубине шаблонного кода.
Явный `vector<bool>` должен заставить программиста удвоить бдительность,
а вот про `vector<T>` в качестве локальной переменной или приватного поля в шаблонном классе можно и не заподозрить, что он бывает `vector<bool>`.

## Неопределённое поведение

Там где типы вывелись неожиданным образом оказывается всего один шаг до неопределённого поведения.
С proxy классом нам в автовыводе переменной с голым `auto` становятся доступны многие способы получения висячих ссылок.
Пример с объявлением переменной `auto b = v[0];` очень легко дополнить до неопределённого поведения.
Достаточно просто добавить в конец вектора достаточно много элементов, чтобы произошла реаллокация.

В качестве бонусного неопределённого поведения мы получаем удивительную возможность забиндиться к висячей ссылке с возвращаемым из функции значением без [предупреждений](https://godbolt.org/z/zWs887Eqs) компилятора (и в случае gcc тоже),
что для `const auto&` и `auto&&` у нас не [получалось](decltype_auto_and_explicit_types.md).
Например, вот так:
```C++
#include <vector>
#include <iostream>

auto foo(bool x, bool y) {
    std::vector<bool> v{x};
    v[0] = v[0] && y;
    return v[0];
}

int main() {
    std::cout << foo(true, false) << std::endl;
}
```
Cанитайзер на этом коде ловит [ошибку работы с памятью](https://godbolt.org/z/3b54s6PW4).

Можно сказать, что пример с возвращением элемента `vector<bool>` довольно искусственный,
но мы уже упоминали, что proxy класс может вернуть и `operator*`.
Строго говоря, вернуть proxy класс может что угодно особенно,
если ваши коллеги и предшественники не ведали страха и знали про proxy классы.

Получить неопределённое поведение с proxy классом можно и без `auto`.
При выводе типов шаблона это тоже весьма просто:
```C++
#include <vector>
#include <iostream>

template <class T>
T sum(T a, T b) {   
    T res;
    res = a + b;
    return res;
}


int main() {
    std::vector<bool> v{true, false};
    std::cout << sum(v[0], v[1]) << std::endl;
}
```
нам стоило всего лишь сделать лишнюю локальную переменную и мы узнали, что у proxy класса ссылки `vector<bool>` есть дефолтный конструктор,
который прописывает в неё `nullptr`.
При вызове `operator=` мы его [разыменовываем](https://godbolt.org/z/zcjP649nh).
Особенно удобно, что санитайзер ловит эту ошибку при `-O0`, а при `-O1` падения не происходит и программа [выводит](https://godbolt.org/z/TfcYjWWEo) `0`.
Кстати, просто `return a + b;` не компилируется.

## Полезные ссылки
1. https://www.researchgate.net/publication/220803585_Performance_of_C_bit-vector_implementations
2. https://eigen.tuxfamily.org/dox/TopicWritingEfficientProductExpression.html
3. https://eigen.tuxfamily.org/dox/TopicLazyEvaluation.html